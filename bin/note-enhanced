#!/usr/bin/env bash

# WayNotes - Enhanced Terminal Note Taking System
# AUR Package: noteticker

set -e

# Colors for enhanced output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;37m'
NC='\033[0m' # No Color

# Configuration
NOTES_DIR="${NOTES_DIR:-$HOME/.local/share/waynotes}"
CONFIG_DIR="${CONFIG_DIR:-$HOME/.config/waynotes}"
MAX_NOTES="${MAX_NOTES:-100}"
NOTE_PREFIX="${NOTE_PREFIX:-*}"

# Ensure directories exist
mkdir -p "$NOTES_DIR"
mkdir -p "$CONFIG_DIR"

# Load config if exists
if [[ -f "$CONFIG_DIR/config" ]]; then
    source "$CONFIG_DIR/config"
fi

# Enhanced print functions
print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

print_header() {
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${WHITE}$1${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# Get note icon with color
get_note_icon() {
    local type="$1"
    case "$type" in
        "todo") echo -e "${YELLOW}[ ]${NC}" ;;
        "idea") echo -e "${CYAN}->${NC}" ;;
        "reminder") echo -e "${RED}!${NC}" ;;
        "quote") echo -e "${PURPLE}\"${NC}" ;;
        "code") echo -e "${GREEN}>${NC}" ;;
        *) echo -e "${BLUE}*${NC}" ;;
    esac
}

# Help function
show_help() {
    print_header "WayNotes - Enhanced Terminal Note Taking System"
    cat << EOF

${WHITE}Usage:${NC} note [OPTIONS] [MESSAGE]

${WHITE}Options:${NC}
    ${GREEN}-h, --help${NC}          Show this help message
    ${GREEN}-l, --list${NC}          List recent notes
    ${GREEN}-c, --clear${NC}         Clear all notes
    ${GREEN}-e, --edit${NC}          Edit the most recent note
    ${GREEN}-s, --search TEXT${NC}   Search notes containing TEXT
    ${GREEN}-t, --type TYPE${NC}     Set note type (default: general)
    ${GREEN}-f, --file FILE${NC}     Save note to specific file
    ${GREEN}--clip${NC}              Capture clipboard content and save as note
    ${GREEN}-v, --version${NC}       Show version

${WHITE}Note Types:${NC}
    ${YELLOW}general${NC}, ${CYAN}todo${NC}, ${GREEN}idea${NC}, ${RED}reminder${NC}, ${PURPLE}quote${NC}, ${BLUE}code${NC}

${WHITE}Examples:${NC}
    ${GRAY}note "Remember to buy groceries"${NC}
    ${GRAY}note -t todo "Fix the bug in login module"${NC}
    ${GRAY}note -t idea "Add dark mode to the app"${NC}
    ${GRAY}note --clip${NC}              # Capture clipboard content
    ${GRAY}note -t quote --clip${NC}     # Capture clipboard as quote
    ${GRAY}note -l${NC}                  # List recent notes
    ${GRAY}note -s "groceries"${NC}      # Search for notes containing "groceries"

${WHITE}Configuration:${NC}
    Set environment variables or edit $CONFIG_DIR/config:
    - NOTES_DIR: Directory to store notes (default: ~/.local/share/waynotes)
    - MAX_NOTES: Maximum number of notes to keep (default: 100)
    - NOTE_PREFIX: Prefix for notes (default: *)
EOF
}

# Version function
show_version() {
    print_header "WayNotes v1.0.0"
    echo -e "${WHITE}AUR Package:${NC} noteticker"
    echo -e "${WHITE}Enhanced with:${NC} Colors, Icons, and Better UX"
}

# Get timestamp
get_timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

# Save note with enhanced output
save_note() {
    local message="$1"
    local note_type="${2:-general}"
    local timestamp=$(get_timestamp)
    local note_file="$NOTES_DIR/notes.txt"
    
    # Create note entry
    local note_entry="$timestamp|$note_type|$message"
    
    # Add to beginning of file (most recent first)
    echo "$note_entry" | cat - "$note_file" > "$note_file.tmp" 2>/dev/null || echo "$note_entry" > "$note_file.tmp"
    mv "$note_file.tmp" "$note_file"
    
    # Trim file if it exceeds MAX_NOTES
    if [[ -f "$note_file" ]]; then
        local line_count=$(wc -l < "$note_file")
        if [[ $line_count -gt $MAX_NOTES ]]; then
            head -n $MAX_NOTES "$note_file" > "$note_file.tmp"
            mv "$note_file.tmp" "$note_file"
        fi
    fi
    
    # Enhanced success message
    local icon=$(get_note_icon "$note_type")
    print_success "Note saved successfully!"
    echo -e "  ${GRAY}Type:${NC} $note_type"
    echo -e "  ${GRAY}Time:${NC} $timestamp"
    echo -e "  ${GRAY}Message:${NC} $message"
}

# Enhanced list notes
list_notes() {
    local count="${1:-10}"
    local note_file="$NOTES_DIR/notes.txt"
    
    if [[ ! -f "$note_file" ]] || [[ ! -s "$note_file" ]]; then
        print_warning "No notes found."
        return
    fi
    
    print_header "Recent Notes"
    
    local i=1
    while IFS='|' read -r timestamp type message; do
        local icon=$(get_note_icon "$type")
        
        echo -e "${WHITE}$i.${NC} $icon ${WHITE}$message${NC}"
        echo -e "    ${GRAY}$timestamp${NC} (${CYAN}$type${NC})"
        echo
        
        ((i++))
        if [[ $i -gt $count ]]; then
            break
        fi
    done < "$note_file"
}

# Enhanced search notes
search_notes() {
    local search_term="$1"
    local note_file="$NOTES_DIR/notes.txt"
    
    if [[ ! -f "$note_file" ]]; then
        print_warning "No notes found."
        return
    fi
    
    print_header "Search Results for '$search_term'"
    
    local found=0
    while IFS='|' read -r timestamp type message; do
        if [[ "$message" =~ $search_term ]] || [[ "$type" =~ $search_term ]]; then
            local icon=$(get_note_icon "$type")
            
            echo -e "$icon ${WHITE}$message${NC}"
            echo -e "    ${GRAY}$timestamp${NC} (${CYAN}$type${NC})"
            echo
            
            ((found++))
        fi
    done < "$note_file"
    
    if [[ $found -eq 0 ]]; then
        print_warning "No notes found matching '$search_term'"
    else
        print_success "Found $found matching note(s)"
    fi
}

# Enhanced clear notes
clear_notes() {
    local note_file="$NOTES_DIR/notes.txt"
    if [[ -f "$note_file" ]]; then
        rm "$note_file"
        print_success "All notes cleared successfully!"
    else
        print_info "No notes to clear."
    fi
}

# Enhanced edit note
edit_note() {
    local note_file="$NOTES_DIR/notes.txt"
    if [[ ! -f "$note_file" ]] || [[ ! -s "$note_file" ]]; then
        print_warning "No notes to edit."
        return
    fi
    
    # Get the first line (most recent note)
    local first_line=$(head -n 1 "$note_file")
    IFS='|' read -r timestamp type message <<< "$first_line"
    
    # Create temporary file for editing
    local temp_file=$(mktemp)
    echo "$message" > "$temp_file"
    
    print_info "Opening editor to edit note..."
    
    # Open editor
    ${EDITOR:-nano} "$temp_file"
    
    # Read edited message
    local edited_message=$(cat "$temp_file")
    rm "$temp_file"
    
    # Update the note
    local new_entry="$timestamp|$type|$edited_message"
    sed -i "1s/.*/$new_entry/" "$note_file"
    
    print_success "Note updated successfully!"
    echo -e "  ${GRAY}New message:${NC} $edited_message"
}

# Main script logic (same as original)
main() {
    local note_type="general"
    local message=""
    local use_clipboard=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -l|--list)
                list_notes "$2"
                exit 0
                ;;
            -c|--clear)
                clear_notes
                exit 0
                ;;
            -e|--edit)
                edit_note
                exit 0
                ;;
            -s|--search)
                if [[ -z "$2" ]]; then
                    print_error "Search term required"
                    exit 1
                fi
                search_notes "$2"
                exit 0
                ;;
            -t|--type)
                if [[ -z "$2" ]]; then
                    print_error "Note type required"
                    exit 1
                fi
                note_type="$2"
                shift 2
                ;;
            -f|--file)
                if [[ -z "$2" ]]; then
                    print_error "File path required"
                    exit 1
                fi
                NOTES_DIR="$(dirname "$2")"
                shift 2
                ;;
            --clip)
                use_clipboard=true
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                message="$1"
                shift
                ;;
        esac
    done
    
    # Handle clipboard capture
    if [[ "$use_clipboard" == true ]]; then
        # Try to get clipboard content
        if command -v xclip >/dev/null 2>&1; then
            message=$(xclip -out -selection clipboard 2>/dev/null)
        elif command -v xsel >/dev/null 2>&1; then
            message=$(xsel --clipboard 2>/dev/null)
        elif command -v wl-copy >/dev/null 2>&1; then
            message=$(wl-paste 2>/dev/null)
        elif command -v pbcopy >/dev/null 2>&1; then
            message=$(pbpaste 2>/dev/null)
        else
            print_error "No clipboard tool found. Please install xclip, xsel, wl-clipboard, or pbcopy."
            exit 1
        fi
        
        # Validate clipboard content
        if [[ -z "$message" ]]; then
            print_error "Clipboard is empty or no content found"
            exit 1
        fi
        
        print_info "Clipboard content captured and saved as note"
    else
        # If no message provided, read from stdin or prompt
        if [[ -z "$message" ]]; then
            if [[ -t 0 ]]; then
                # Interactive mode
                echo -e -n "${CYAN}Enter note: ${NC}"
                read -r message
            else
                # Read from stdin
                message=$(cat)
            fi
        fi
        
        # Validate message
        if [[ -z "$message" ]]; then
            print_error "No message provided"
            exit 1
        fi
    fi
    
    # Save the note
    save_note "$message" "$note_type"
}

# Run main function with all arguments
main "$@"
